/* [lee] pervasive typing of the WESL into types seems very powerful. 

  And it's not just types that are produced, but reified references to structs and fns
  that can be passed as runtime parameters for libraries.

  JSDoc, interesting.. I've not really explored it. Is it best to do both jsdoc and .d.ts? 

  Are the type formats and the reified reference format simple enough that we can lock them down,
  write a stable spec for the format, and expect tools to support them long term? 
  If not let's generate them on the consumer side somehow.
  But they seem pretty simple..
*/

// AUTO-GENERATED BY WESL. Original filename: ./alpha.wesl
// @ts-check

// ---
// Type utils
// ---

/**
 * @template T
 * @typedef {T extends { __value: infer TValue } ? TValue : never} ValueOf
 */

/**
 * @template T
 * @typedef {T extends Record<string, unknown> ? { [Key in keyof T]: ValueOf<T[Key]> } : never} ValueOfRecord
 */

// ---
// Value types
// ---

/**
 * @typedef {object} vec3f
 * @prop {'vec3f'} kind
 * @prop {number} x
 * @prop {number} y
 * @prop {number} z
 */

// ---
// Schema types
// ---

/**
 * @typedef {object} F32
 * @prop {'f32'} type
 * @prop {number} __value
 */
const f32 = /**@type{F32}*/ ({
  type: 'f32',
});

/**
 * @typedef {object} Vec3f
 * @prop {'vec3f'} type
 * @prop {vec3f} __value
 */
const vec3f = /**@type{Vec3f}*/ ({
  type: 'vec3f',
});

/**
 * @template T
 * @typedef {object} WgslStruct
 * @prop {'struct'} type
 * @prop {T} props
 * @prop {string=} label
 * @prop {ValueOfRecord<T>} __value
 */
const struct = /**@type{<T>(label:string,props:T)=>WgslStruct<T>}*/ (
  (label, props) => ({
    type: 'struct',
    label,
    props,
  })
);

// ---
// Function types
// ---

/**
 * @template TArgs,TReturns
 * @typedef {object} WgslFn
 * @prop {'fn'} type
 * @prop {TArgs} args
 * @prop {TReturns} returns
 * @prop {string=} label
 */
const fn =
  /**@type{<TArgs extends unknown[] | [],TReturns>(label:string,args:TArgs,returns:TReturns,body:unknown)=>WgslFn<TArgs, TReturns>}*/ (
    (label, args, returns, body) => ({
      type: 'fn',
      label,
      args,
      returns,
      body,
    })
  );

// ---
// Definitions
// ---

export const half = fn(
  'half',
  [f32],
  f32,
  `(value: f32) -> f32 {
  return value * 0.5;
}`
);

export const double = fn(
  'double',
  [f32],
  f32,
  `(value: f32) -> f32 {
  return value * 2.;
}`
);

export const add = fn(
  'add',
  [f32, f32],
  f32,
// [lee] Putting shader text inside is here is convenient... the linker needs to find the sources for functions,
// and we'd all like typescript control of linking in addition to wgsl control of linking for advanced users
// who want typescript control of how shaders get glued together.
// But there's potentially more context the linker would need than just the function text. 
// conditions now, later generics or even 'module generics' (generics on a 'namespace'), etc.
// Maybe better to index into the original source so that context is available? 
// Side note, dynamic linking under typescript control is more for the advanced user 
// (I want it, tried it in thimbleberry a bit. use.gpu does it, perhaps a couple of other projects)
// but sharing the struct types is useful for almost everyone. 
//
  `(a: f32, b: f32) -> f32 {
  return a + b;
}`
);

export const Gradient = struct('Gradient', {
  from: vec3f,
  to: vec3f,
});
